<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text" xml:lang="en">Nigel's Homepage</title><link type="application/atom+xml" rel="self" href="http://nigelarmstrong.me/atom.xml"/><link href="http://nigelarmstrong.me/"/><id>http://nigelarmstrong.me/</id><updated>2017-06-23T22:11:19Z</updated><author><name>Nigel Armstrong</name><email>legonigel@gmail.com</email></author><rights type="text">Copyright © 2017 Nigel Armstrong. All rights reserved.</rights><entry><title type="text">Subprocessing in Python</title><link rel="alternate" type="text/html" href="http://nigelarmstrong.me/2015/04/python-subprocess/" /><id>http://nigelarmstrong.me/2015/04/python-subprocess</id><published>2015-04-25T22:30:00Z</published><updated>2015-04-25T22:30:00Z</updated><content type="html"><![CDATA[ <p>I recently spent some time trying to get Python to play nicely with an interactive subprocess. By interactive, I mean that the subprocess is a command line program which waits for input from the user, then acts on that input and prints back out to the command line. I read a lot of documentation and looked for examples as to how to make this work, but couldn’t really find anything complete. After some trial and error, I came to the result I will share with you.</p><p>Note: This is written for python 2.7, for the <a href="https://pypi.python.org/pypi/subprocess32/">Subprocess32</a> module (a backport of the subprocess module from python 3.2)</p><h2 id="introduction-to-python-subprocesses">Introduction to Python subprocesses</h2><p>Python subprocesses can be super useful. A lot of people use them to execute simple shell commands
(such as <a href="http://stackoverflow.com/questions/12605498/how-to-use-subprocess-popen-python">this Stack Overflow post</a>
or <a href="http://stackoverflow.com/questions/2715847/python-read-streaming-input-from-subprocess-communicate">this other post</a>).
If the application runs and returns quickly, then  <a href="https://docs.python.org/3.2/library/subprocess.html#subprocess.call"><code>subprocess.call</code></a> is probably the best way to call the subprocesses. In other related situations <code>subprocess.check_call</code> or <code>subprocess.check_output</code> are similar alternatives. But all of these wait on the program to return. In order to run a concurrent subprocess, it is necessary to use subprocess’s <a href="https://docs.python.org/3.2/library/subprocess.html#subprocess.Popen"><code>Popen</code></a>.</p><h2 id="popen-usage">Popen usage</h2><p><code>Popen</code> is normally used where the command is run, then the output is read from it using the <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.communicate"><code>Popen.communicate</code></a> method. This method allows us to pass data into the standard input of the subprocess and read from the subprocess’s standard output and standard error. The issue with the communicate method is that, similar to the methods discussed above, it waits for the process to terminate. This is no good for an interactive process.</p><h2 id="interactive-popen">Interactive Popen</h2><p>Now we can finally arrive to what I want, an interactive subprocess. This is one part that the docs don’t really discuss well. In order to do this, we need to make the subprocess with pipes.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">ps</span><span class="o">=</span><span class="n">subprocess32</span><span class="o">.</span><span class="n">Popen</span><span class="p">([</span><span class="s">&#39;command&#39;</span><span class="p">,</span><span class="s">&#39;argument&#39;</span><span class="p">],</span><span class="n">stdout</span><span class="o">=</span><span class="n">subprocess32</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span><span class="n">stderr</span><span class="o">=</span><span class="n">subprocess32</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span><span class="n">stdin</span><span class="o">=</span><span class="n">subprocess32</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span></code></pre></div><p>This makes it so that the process is created with pipes and will run until it terminates. Unlike using <code>communicate</code> to pass data to the subprocess, pipes will not wait on the process to terminate before returning, however they will wait for data before returning. This means that if you expect the subprocess to output something, but it doesn’t then your program will hang. For my application this was a problem.</p><p>By setting file status flags on the stdout and stderr of the program, we can use nonblocking reads. This is accomplished with the use of <a href="https://docs.python.org/2/library/fcntl.html">fcntl</a>.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span><span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span><span class="p">)</span><span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span><span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span><span class="p">)</span></code></pre></div><p>Finally we can get to where we can read from the stdout and stderr at our leisure.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">stdout</span><span class="o">=</span><span class="n">ps</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="n">stderr</span><span class="o">=</span><span class="n">ps</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">read</span><span class="p">()</span></code></pre></div><p>But there is an issue. If there is no data in the stdout or stderr buffer then python throws an <code>IOError: [Errno 11] Resource temporarily unavailable</code>. For my purpose, I ignore any errors during the read from stdout and stderr and just assume there was no output. So my reads now look like this:</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">stdout</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="n">stderr</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="k">try</span><span class="p">:</span><span class="n">stdout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="k">except</span><span class="ne">Exception</span><span class="p">:</span><span class="k">pass</span><span class="k">try</span><span class="p">:</span><span class="n">stderr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="k">except</span><span class="ne">Exception</span><span class="p">:</span><span class="k">pass</span></code></pre></div><h2 id="example">Example</h2><p>Finally, an example program with everything:</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import necessary modules</span><span class="kn">import</span><span class="nn">os</span><span class="o">,</span><span class="nn">fcntl</span><span class="o">,</span><span class="nn">subprocess32</span><span class="c"># Make the subprocess</span><span class="n">ps</span><span class="o">=</span><span class="n">subprocess32</span><span class="o">.</span><span class="n">Popen</span><span class="p">([</span><span class="s">&#39;command&#39;</span><span class="p">,</span><span class="s">&#39;argument&#39;</span><span class="p">],</span><span class="n">stdout</span><span class="o">=</span><span class="n">subprocess32</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span><span class="n">stderr</span><span class="o">=</span><span class="n">subprocess32</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span><span class="n">stdin</span><span class="o">=</span><span class="n">subprocess32</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span><span class="c"># Fix the pipes to be nonblocking</span><span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span><span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span><span class="p">)</span><span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span><span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span><span class="p">)</span><span class="k">while</span><span class="bp">True</span><span class="p">:</span><span class="c"># Main loop</span><span class="n">stdout</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="n">stderr</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="c"># Read from stdout</span><span class="k">try</span><span class="p">:</span><span class="n">stdout</span><span class="o">=</span><span class="n">ps</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="k">except</span><span class="ne">Exception</span><span class="p">:</span><span class="k">pass</span><span class="c"># Read from stderr</span><span class="k">try</span><span class="p">:</span><span class="n">stderr</span><span class="o">=</span><span class="n">ps</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="k">except</span><span class="ne">Exception</span><span class="p">:</span><span class="k">pass</span></code></pre></div><p>Of course there is one thing we still need to do: <a href="https://docs.python.org/2/library/stdtypes.html#file.write">Write</a> to stdin. This is easy.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">ps</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;some_command_to_the_subprocess</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span></code></pre></div><p>Don’t forget to put the newline at the end of the write so the program sees that you actually pressed return after writing the line. As the docs for write point out, you may also need to <code>flush</code> after writing, depending on the buffering.</p><br><hr><p>You’ve just read about <strong><a href="http://nigelarmstrong.me/2015/04/python-subprocess/">Subprocessing in Python</a></strong> on <strong><a href="http://nigelarmstrong.me/">Nigel's Homepage</a></strong>.</p>
 ]]></content></entry></feed>
